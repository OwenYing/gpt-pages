<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google Analytics 4 -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-T69M8TNFWB"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-T69M8TNFWB');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Frequency Detector - GPT Ideas Hub</title>
    <link rel="stylesheet" href="../styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Professional Audio Processing Libraries -->
    <script src="https://unpkg.com/pitchy@4.0.7/umd/pitchy.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ml5@latest/dist/ml5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        .page-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .page-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 0;
            background: var(--gradient-primary);
            color: white;
            border-radius: var(--border-radius);
            position: relative;
            overflow: hidden;
        }
        
        .page-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="75" cy="75" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="50" cy="10" r="0.5" fill="rgba(255,255,255,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.3;
        }
        
        .page-header-content {
            position: relative;
            z-index: 2;
        }
        
        .page-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 16px;
            font-family: 'Space Grotesk', sans-serif;
        }
        
        .page-meta {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .page-category-badge {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .page-number-badge {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: var(--primary-color);
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: var(--border-radius);
            text-decoration: none;
            font-weight: 500;
            transition: var(--transition);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .back-button:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .content-section {
            background: var(--card-bg);
            padding: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
        }
        
        .main-tuner-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            max-width: 1200px;
            margin: 0 auto;
            align-items: start;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            padding: 40px;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
        }
        
        .tuner-left {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 30px;
            box-shadow: var(--shadow);
        }
        
        .tuner-right {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 30px;
            box-shadow: var(--shadow);
        }
        
        .section-title {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
            text-align: center;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }
        
        .tuner-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .tuner-display {
            text-align: center;
            padding: 30px;
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            border: 2px solid var(--border-color);
            box-shadow: var(--shadow-sm);
        }
        
        .note-display {
            font-size: 4rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 20px;
            font-family: 'Space Grotesk', sans-serif;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
        }
        
        .note-display.updating {
            transform: scale(1.05);
            color: var(--primary-dark);
        }
        
        .frequency-display {
            font-size: 1.5rem;
            color: var(--text-secondary);
            margin-bottom: 15px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
        }
        
        .frequency-display.updating {
            transform: scale(1.02);
            color: var(--primary-color);
        }
        
        .note-display.persisted,
        .frequency-display.persisted {
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
        

        
        .confidence-meter {
            margin-bottom: 30px;
            text-align: center;
        }
        
        .confidence-bar {
            width: 200px;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin: 0 auto 8px;
            overflow: hidden;
        }
        
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger-color), var(--warning-color), var(--success-color));
            width: 0%;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1), background 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 4px;
        }
        
        .confidence-text {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 500;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .tuner-visual {
            width: 200px;
            height: 200px;
            margin: 0 auto 30px;
            position: relative;
        }
        
        .tuner-needle {
            width: 4px;
            height: 80px;
            background: var(--primary-color);
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            border-radius: 2px;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .tuner-needle.in-tune {
            background: var(--success-color);
        }
        
        .tuner-needle.sharp {
            background: var(--warning-color);
            transform: translate(-50%, -50%) rotate(15deg);
        }
        
        .tuner-needle.flat {
            background: var(--warning-color);
            transform: translate(-50%, -50%) rotate(-15deg);
        }
        
        .tuner-center {
            width: 20px;
            height: 20px;
            background: var(--text-secondary);
            border-radius: 50%;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        .tuner-lines {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .tuner-line {
            position: absolute;
            width: 2px;
            height: 20px;
            background: var(--border-color);
            left: 50%;
            transform: translateX(-50%);
        }
        
        .tuner-line:nth-child(1) { top: 20px; }
        .tuner-line:nth-child(2) { top: 40px; }
        .tuner-line:nth-child(3) { top: 60px; }
        .tuner-line:nth-child(4) { top: 80px; }
        .tuner-line:nth-child(5) { top: 100px; }
        .tuner-line:nth-child(6) { top: 120px; }
        .tuner-line:nth-child(7) { top: 140px; }
        .tuner-line:nth-child(8) { top: 160px; }
        
        .tuner-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .control-group {
            text-align: center;
        }
        
        .control-button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            width: 100%;
            margin-bottom: 10px;
        }
        
        .control-button:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .control-button:disabled {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .control-button.recording {
            background: var(--danger-color);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* String Reference Styles */
        .string-reference {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .string-item {
            background: var(--bg-secondary);
            padding: 18px 15px;
            border-radius: var(--border-radius);
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            box-shadow: var(--shadow-sm);
        }
        
        .string-item:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .string-item.active {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
        }
        
        .string-item.detected {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
            animation: pulse-detect 1s infinite;
        }
        
        .string-item.in-tune {
            border-color: var(--success-color);
            background: var(--success-color);
            color: white;
        }
        
        .string-item.sharp,
        .string-item.flat {
            border-color: var(--warning-color);
            background: var(--warning-color);
            color: white;
        }
        
        .string-number {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .string-note {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .string-frequency {
            font-size: 1rem;
            opacity: 0.8;
            font-family: 'Space Grotesk', monospace;
        }
        
        @keyframes pulse-detect {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .status-indicator {
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 20px 0;
            text-align: center;
            font-weight: 500;
        }
        
        .status-indicator.success {
            background: var(--success-bg);
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }
        
        .status-indicator.warning {
            background: var(--warning-bg);
            color: var(--warning-color);
            border: 1px solid var(--warning-color);
        }
        
        .status-indicator.error {
            background: var(--danger-bg);
            color: var(--danger-color);
            border: 1px solid var(--danger-color);
        }
        
        .instructions {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: var(--border-radius);
            border-left: 4px solid var(--primary-color);
        }
        
        .instructions h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .instructions ol {
            margin: 0;
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
            line-height: 1.6;
        }
        
        @media (max-width: 768px) {
            .page-title {
                font-size: 2rem;
            }
            
            .note-display {
                font-size: 3rem;
            }
            
            .tuner-controls {
                grid-template-columns: 1fr;
            }
            
            .main-tuner-section {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 15px;
            }
            
            .tuner-left,
            .tuner-right {
                padding: 20px;
            }
            
            .string-reference {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
        }
    </style>
</head>
<body class="individual-page">
    <a href="../index.html" class="back-button">
        <i class="fas fa-arrow-left"></i>
        Back to Home
    </a>

    <div class="page-content">
        <div class="page-header">
            <div class="page-header-content">
                <h1 class="page-title">Professional Frequency Detector</h1>
                <div class="page-meta">
                    <span class="page-category-badge">Music & Audio</span>
                    <span class="page-number-badge">#101</span>
                </div>
            </div>
        </div>

        <div class="main-tuner-section">
            <div class="tuner-left">
                <div class="tuner-display">
                    <div class="note-display" id="noteDisplay">--</div>
                    <div class="frequency-display" id="frequencyDisplay">0 Hz</div>
                    <div class="confidence-meter" id="confidenceMeter">
                        <div class="confidence-bar">
                            <div class="confidence-fill" id="confidenceFill"></div>
                        </div>
                        <div class="confidence-text">Confidence: <span id="confidenceText">0%</span></div>
                    </div>
                
                    <div class="tuner-visual">
                        <div class="tuner-lines">
                            <div class="tuner-line"></div>
                            <div class="tuner-line"></div>
                            <div class="tuner-line"></div>
                            <div class="tuner-line"></div>
                            <div class="tuner-line"></div>
                            <div class="tuner-line"></div>
                            <div class="tuner-line"></div>
                            <div class="tuner-line"></div>
                        </div>
                        <div class="tuner-needle" id="tunerNeedle"></div>
                        <div class="tuner-center"></div>
                    </div>
                    
                    <div class="tuner-controls">
                        <div class="control-group">
                            <button class="control-button" id="startButton">
                                <i class="fas fa-microphone"></i> Start Detection
                            </button>
                            <button class="control-button" id="stopButton" disabled>
                                <i class="fas fa-stop"></i> Stop
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tuner-right">
                <h3 class="section-title"><i class="fas fa-list"></i> String Reference</h3>
                <div class="string-reference">
                    <div class="string-item" data-string="6" data-note="E" data-frequency="82.41">
                        <div class="string-number">6th String</div>
                        <div class="string-note">E (Low)</div>
                        <div class="string-frequency">82.41 Hz</div>
                    </div>
                    <div class="string-item" data-string="5" data-note="A" data-frequency="110.00">
                        <div class="string-number">5th String</div>
                        <div class="string-note">A</div>
                        <div class="string-frequency">110.00 Hz</div>
                    </div>
                    <div class="string-item" data-string="4" data-note="D" data-frequency="146.83">
                        <div class="string-number">4th String</div>
                        <div class="string-note">D</div>
                        <div class="string-frequency">146.83 Hz</div>
                    </div>
                    <div class="string-item" data-string="3" data-note="G" data-frequency="196.00">
                        <div class="string-number">3rd String</div>
                        <div class="string-note">G</div>
                        <div class="string-frequency">196.00 Hz</div>
                    </div>
                    <div class="string-item" data-string="2" data-note="B" data-frequency="246.94">
                        <div class="string-number">2nd String</div>
                        <div class="string-note">B</div>
                        <div class="string-frequency">246.94 Hz</div>
                    </div>
                    <div class="string-item" data-string="1" data-note="E" data-frequency="329.63">
                        <div class="string-number">1st String</div>
                        <div class="string-note">E (High)</div>
                        <div class="string-frequency">329.63 Hz</div>
                    </div>
                </div>
            </div>
        </div>

            <div class="content-section">
                <div class="instructions">
                    <h3 class="section-title"><i class="fas fa-info-circle"></i> How to Use</h3>
                    <ol>
                        <li><strong>Start Detection:</strong> Click "Start Detection" and allow microphone access when prompted.</li>
                        <li><strong>Make Any Sound:</strong> Speak, sing, play an instrument, or make any sound near your microphone.</li>
                        <li><strong>Real-Time Display:</strong> The detector shows the frequency of ANY sound in real-time.</li>
                        <li><strong>No Restrictions:</strong> Detects frequencies from 1 Hz to 20,000+ Hz (full audio spectrum).</li>
                        <li><strong>Confidence Meter:</strong> Shows how strong the detected signal is.</li>
                        <li><strong>Note Display:</strong> Shows the musical note closest to the detected frequency.</li>
                    </ol>
                </div>
            </div>

            <div class="content-section">
                <h3 class="section-title"><i class="fas fa-lightbulb"></i> Tips for Best Results</h3>
                <ul>
                    <li><strong>Hybrid Professional System:</strong> Combines 4 detection methods for maximum accuracy</li>
                    <li><strong>Pitchy.js (YIN):</strong> Professional-grade pitch detection algorithm</li>
                    <li><strong>ML5.js:</strong> Machine learning-based audio analysis</li>
                    <li><strong>TensorFlow.js:</strong> Enhanced FFT with advanced signal processing</li>
                    <li><strong>Fallback FFT:</strong> Reliable backup system for any environment</li>
                    <li><strong>Real-Time Response:</strong> Immediate frequency detection and display</li>
                    <li><strong>Universal Detection:</strong> Works with any sound source</li>
                    <li><strong>Cross-Browser Compatible:</strong> Works reliably in all modern browsers</li>
                    <li><strong>Method Display:</strong> Shows detection method and confidence level</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        class GuitarTuner {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.isRecording = false;
                this.animationFrame = null;
                this.analysisTimer = null; // Timer for stable analysis updates
                
                // Frequency persistence properties
                this.lastDetectedFrequency = null;
                this.lastDetectedNote = null;
                this.lastDetectedString = null;
                this.frequencyResetTimer = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.setupStringReference();
                
                // Check if Pitchy.js is loaded
                this.checkPitchyStatus();
            }
            
            initializeElements() {
                this.noteDisplay = document.getElementById('noteDisplay');
                this.frequencyDisplay = document.getElementById('frequencyDisplay');
                this.confidenceFill = document.getElementById('confidenceFill');
                this.confidenceText = document.getElementById('confidenceText');
                this.tunerNeedle = document.getElementById('tunerNeedle');
                this.startButton = document.getElementById('startButton');
                this.stopButton = document.getElementById('stopButton');
                
                // Debug: Check if elements are found
                console.log('Elements found:', {
                    noteDisplay: !!this.noteDisplay,
                    frequencyDisplay: !!this.frequencyDisplay,
                    confidenceFill: !!this.confidenceFill,
                    confidenceText: !!this.confidenceText,
                    tunerNeedle: !!this.tunerNeedle,
                    startButton: !!this.startButton,
                    stopButton: !!this.stopButton
                });
            }
            
            setupEventListeners() {
                console.log('Setting up event listeners...');
                console.log('Start button:', this.startButton);
                console.log('Stop button:', this.stopButton);
                
                if (this.startButton) {
                    this.startButton.addEventListener('click', () => {
                        console.log('Start button clicked!');
                        this.startTuning();
                    });
                } else {
                    console.error('Start button not found!');
                }
                
                if (this.stopButton) {
                    this.stopButton.addEventListener('click', () => this.stopTuning());
                } else {
                    console.error('Stop button not found!');
                }
            }
            
            setupStringReference() {
                // Setup string reference items
                const stringItems = document.querySelectorAll('.string-item');
                stringItems.forEach(item => {
                    item.addEventListener('click', () => {
                        this.selectString(item.dataset.string, item.dataset.note, item.dataset.frequency);
                    });
                });
            }
            
            checkPitchyStatus() {
                console.log('ðŸŽ¯ Hybrid Professional-Grade Frequency Detection System Loaded');
                console.log('âœ… Enhanced Bass Detection - Optimized for 6th string E (82.41 Hz)');
                console.log('âœ… Pitchy.js (YIN) - Professional pitch detection');
                console.log('âœ… ML5.js - Machine learning audio analysis');
                console.log('âœ… TensorFlow.js - Enhanced FFT processing');
                console.log('âœ… Fallback FFT - Reliable backup system');
            }
            
            selectString(stringNumber, note, frequency) {
                // Remove active class from all elements
                this.clearActiveStates();
                
                // Add active class to selected string elements
                const stringElements = document.querySelectorAll(`[data-string="${stringNumber}"]`);
                stringElements.forEach(el => el.classList.add('active'));
                
                // Update display
                this.noteDisplay.textContent = note;
                this.frequencyDisplay.textContent = `${frequency} Hz`;
                
                // Reset needle
                this.tunerNeedle.className = 'tuner-needle';
                
                // Remove active class after 3 seconds
                setTimeout(() => {
                    this.clearActiveStates();
                    this.noteDisplay.textContent = '--';
                    this.frequencyDisplay.textContent = '0 Hz';
                }, 3000);
            }
            
            clearActiveStates() {
                // Remove active class from all guitar elements
                const allElements = document.querySelectorAll('.tuning-peg, .guitar-string, .string-info-item');
                allElements.forEach(el => el.classList.remove('active'));
            }
            
            async startTuning() {
                console.log('startTuning called!');
                try {
                    console.log('Requesting microphone access...');
                    
                    // Test if getUserMedia is available
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('getUserMedia not supported in this browser');
                    }
                    
                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    console.log('Microphone access granted!');
                    
                    // Create audio context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    
                    // Connect audio nodes
                    this.microphone.connect(this.analyser);
                    
                    // Configure analyser for optimal bass detection (especially 6th string E)
                    this.analyser.fftSize = 16384; // Even larger FFT for maximum low-frequency resolution
                    this.analyser.smoothingTimeConstant = 0.1; // Minimal smoothing for precise bass detection
                    this.analyser.minDecibels = -120; // Very low threshold to catch weak bass frequencies
                    this.analyser.maxDecibels = -10; // Higher upper limit for bass dynamics
                    
                    // Start analysis
                    this.isRecording = true;
                    this.startButton.disabled = true;
                    this.stopButton.disabled = false;
                    this.startButton.classList.add('recording');
                    
                    console.log('Starting audio analysis...');
                    await this.analyzeAudio();
                    
                } catch (error) {
                    console.error('Error in startTuning:', error);
                    this.showStatus(`Error: ${error.message}`, 'error');
                }
            }
            
            stopTuning() {
                this.isRecording = false;
                this.startButton.disabled = false;
                this.stopButton.disabled = true;
                this.startButton.classList.remove('recording');
                
                // Clear both animation frame and analysis timer
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                
                if (this.analysisTimer) {
                    clearTimeout(this.analysisTimer);
                    this.analysisTimer = null;
                }
                
                // Clear frequency reset timer
                if (this.frequencyResetTimer) {
                    clearTimeout(this.frequencyResetTimer);
                    this.frequencyResetTimer = null;
                }
                
                if (this.microphone && this.microphone.mediaStream) {
                    this.microphone.mediaStream.getTracks().forEach(track => track.stop());
                }
                
                // Reset display immediately when stopping
                this.resetDisplayToZero();
            }
            
            async analyzeAudio() {
                if (!this.isRecording) return;
                
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyser.getByteFrequencyData(dataArray);
                
                // Simple guitar string detection
                const result = await this.analyzeGuitarAudio(dataArray);
                
                if (result.detected) {
                    // Store the last detected values for persistence
                    this.lastDetectedFrequency = result.frequency;
                    this.lastDetectedNote = result.note;
                    this.lastDetectedString = result.string;
                    
                    // Clear any existing reset timer
                    if (this.frequencyResetTimer) {
                        clearTimeout(this.frequencyResetTimer);
                        this.frequencyResetTimer = null;
                    }
                    
                    // Display clean note name without octave
                    const cleanNoteName = this.getCleanNoteName(result.note);
                    this.noteDisplay.textContent = cleanNoteName;
                    this.frequencyDisplay.textContent = `${result.frequency.toFixed(1)} Hz`;
                    
                    // Remove persisted class for fresh detection
                    this.noteDisplay.classList.remove('persisted');
                    this.frequencyDisplay.classList.remove('persisted');
                    
                    // Update needle to show tuning status
                    if (result.string && result.cents !== undefined) {
                        if (Math.abs(result.cents) <= 50) { // 50 cents = in tune (25Hz tolerance)
                            this.tunerNeedle.className = 'tuner-needle in-tune';
                        } else if (result.cents > 0) {
                            this.tunerNeedle.className = 'tuner-needle sharp';
                        } else {
                            this.tunerNeedle.className = 'tuner-needle flat';
                        }
                    } else {
                        this.tunerNeedle.className = 'tuner-needle detected';
                    }
                    
                    // Update confidence meter with frequency accuracy
                    const frequencyAccuracy = result.noteFrequency ? Math.abs(result.frequency - result.noteFrequency) : null;
                    this.updateConfidence(result.confidence, frequencyAccuracy, result);
                    
                    // Update string reference visual state
                    this.updateStringReferenceVisual(result);
                } else {
                    // No significant audio detected - check if we should persist the last detection
                    if (this.lastDetectedFrequency && this.lastDetectedNote) {
                        // Keep the last detection for 3 seconds
                        if (!this.frequencyResetTimer) {
                            this.frequencyResetTimer = setTimeout(() => {
                                this.resetDisplayToZero();
                            }, 3000); // 3 second delay
                        }
                        
                        // Display the last detected values (don't reset yet)
                        const cleanNoteName = this.getCleanNoteName(this.lastDetectedNote);
                        this.noteDisplay.textContent = cleanNoteName;
                        this.frequencyDisplay.textContent = `${this.lastDetectedFrequency.toFixed(1)} Hz`;
                        
                        // Add persisted class to show these are from previous detection
                        this.noteDisplay.classList.add('persisted');
                        this.frequencyDisplay.classList.add('persisted');
                        
                        // Keep the last tuning status
                        if (this.lastDetectedString) {
                            // Keep the last string visual state
                        }
                    } else {
                        // No previous detection to persist, reset immediately
                        this.resetDisplayToZero();
                    }
                }
                
                // Use a slower, more stable timer instead of fast requestAnimationFrame
                // This prevents flickering and provides smoother animations
                if (this.analysisTimer) {
                    clearTimeout(this.analysisTimer);
                }
                
                this.analysisTimer = setTimeout(() => {
                    this.analyzeAudio().catch(error => {
                        console.error('Error in analyzeAudio:', error);
                    });
                }, 100); // Update every 100ms instead of every 16ms (60fps)
            }
            
            async analyzeGuitarAudio(freqData) {
                // Calculate signal strength
                const signalStrength = this.calculateSignalStrength(freqData);
                
                // Lower threshold for better sensitivity
                if (signalStrength < 25) {
                    return { detected: false };
                }
                
                // GUITAR SOUND FILTERING: Check if this sounds like a guitar string
                const guitarFilterResult = this.filterGuitarSounds(freqData, signalStrength);
                this.lastFilterResult = guitarFilterResult; // Store for display purposes
                
                if (!guitarFilterResult.isGuitar) {
                    console.log(`Filtered out non-guitar sound: ${guitarFilterResult.reason}`);
                    return { detected: false };
                }
                
                // Use hybrid professional-grade detection
                const simpleResult = await this.findFrequencySimple(freqData);
                if (simpleResult.frequency === 0) {
                    return { detected: false };
                }
                
                let frequency = simpleResult.frequency;
                
                // SPECIALIZED LOW E DETECTION: Enhanced accuracy for 6th string (Low E)
                if (frequency >= 75 && frequency <= 95) { // Low E range (82.41 Hz Â± ~12 Hz)
                    const lowEResult = this.enhancedLowEDetection(freqData, frequency);
                    if (lowEResult.improved) {
                        frequency = lowEResult.frequency;
                        simpleResult.method = `enhanced-low-e-${simpleResult.method}`;
                        console.log(`Low E enhanced: ${simpleResult.frequency}Hz â†’ ${frequency}Hz (${lowEResult.confidence.toFixed(2)} confidence)`);
                    }
                }
                
                // Check if detected frequency might be a harmonic of a lower fundamental
                // Only apply harmonic correction for frequencies above 200 Hz to avoid over-correction
                if (frequency > 200) {
                    const harmonicCheck = this.checkForHarmonic(freqData, frequency, this.audioContext.sampleRate, this.analyser.fftSize);
                    
                    if (harmonicCheck.isHarmonic && harmonicCheck.fundamentalStrength > 20) {
                        // Only use fundamental if it's significantly stronger than the harmonic
                        const harmonicStrength = freqData[Math.floor(frequency * this.analyser.fftSize / this.audioContext.sampleRate)];
                        const strengthRatio = harmonicCheck.fundamentalStrength / harmonicStrength;
                        
                        if (strengthRatio > 1.5) { // Fundamental must be 50% stronger
                            frequency = harmonicCheck.fundamental;
                            simpleResult.method = `fundamental-${simpleResult.method}`;
                            console.log(`Harmonic corrected: ${harmonicCheck.harmonic}Hz â†’ ${harmonicCheck.fundamental}Hz (${strengthRatio.toFixed(2)}x stronger)`);
                        }
                    }
                }
                
                // No frequency range restrictions - detect ANY frequency
                if (frequency < 1) { // Only filter out extremely low frequencies (below 1 Hz)
                    return { detected: false };
                }
                
                // Detect which guitar string is being played
                const detectedString = this.detectGuitarString(frequency);
                const note = this.frequencyToNote(frequency);
                
                // Calculate cents deviation from the target frequency
                let cents = 0;
                if (detectedString) {
                    cents = this.calculateCents(frequency, detectedString.frequency);
                }
                
                // Calculate confidence based on frequency accuracy to the target note
                let confidence = 0;
                
                if (note.frequency > 0) {
                    // Calculate how close the detected frequency is to the target note
                    const frequencyDifference = Math.abs(frequency - note.frequency);
                    const maxAcceptableDifference = 25; // Hz tolerance for 100% confidence (25Hz = in tune)
                    
                    if (frequencyDifference <= maxAcceptableDifference) {
                        // 100% confidence when within 25Hz of target note (in tune)
                        confidence = 100;
                    } else {
                        // Decrease confidence based on distance from target note
                        const confidenceDrop = Math.min(90, (frequencyDifference - maxAcceptableDifference) * 2);
                        confidence = Math.max(10, 100 - confidenceDrop);
                    }
                    
                    // If a guitar string is detected, use cents for more precise confidence
                    if (detectedString) {
                        const centsDeviation = Math.abs(cents);
                        
                        // Special confidence boost for Low E (6th string)
                        if (detectedString.string === 6) {
                            // Low E gets extra confidence boost due to enhanced detection
                            if (centsDeviation <= 50) {
                                confidence = Math.min(100, confidence + 30); // Extra boost for Low E
                            } else if (centsDeviation <= 100) {
                                confidence = Math.min(100, confidence + 20); // Extra boost for Low E
                            } else if (centsDeviation <= 200) {
                                confidence = Math.min(100, confidence + 10); // Small boost for Low E
                            } else {
                                confidence = Math.max(10, confidence - 10); // Less penalty for Low E
                            }
                        } else {
                            // Standard confidence calculation for other strings
                            if (centsDeviation <= 50) {
                                confidence = Math.min(100, confidence + 20);
                            } else if (centsDeviation <= 100) {
                                confidence = Math.min(100, confidence + 10);
                            } else if (centsDeviation <= 200) {
                                // Acceptable tuning: no change
                            } else {
                                // Poor tuning: reduce confidence
                                confidence = Math.max(10, confidence - 20);
                            }
                        }
                    }
                } else {
                    // Fallback to signal strength if no note detected
                    confidence = Math.min(100, Math.round((signalStrength / 255) * 100));
                }
                
                return {
                    detected: true,
                    frequency: frequency,
                    note: note.name,
                    noteFrequency: note.frequency,
                    string: detectedString ? detectedString.string : null,
                    stringNote: detectedString ? detectedString.note : null,
                    cents: cents,
                    confidence: confidence,
                    method: simpleResult.method
                };
            }
            

            
            calculateSignalStrength(freqData) {
                // Calculate signal strength across ALL frequencies - no restrictions
                let sum = 0;
                let count = 0;
                
                for (let i = 0; i < freqData.length; i++) {
                    if (freqData[i] > 0) {
                        sum += freqData[i];
                        count++;
                    }
                }
                
                // Return average signal strength across all frequencies
                return count > 0 ? sum / count : 0;
            }
            
            findStrongestFrequency(freqData) {
                // Use parabolic interpolation for more accurate frequency detection
                let maxIndex = 0;
                let maxValue = 0;
                
                // Focus on guitar-relevant frequencies (50-600 Hz)
                const minBin = Math.floor(50 * this.analyser.fftSize / this.audioContext.sampleRate);
                const maxBin = Math.floor(600 * this.analyser.fftSize / this.audioContext.sampleRate);
                
                // Find the bin with maximum amplitude
                for (let i = minBin; i <= maxBin && i < freqData.length; i++) {
                    if (freqData[i] > maxValue) {
                        maxValue = freqData[i];
                        maxIndex = i;
                    }
                }
                
                // Use parabolic interpolation for sub-bin accuracy
                let interpolatedIndex = maxIndex;
                
                if (maxIndex > 0 && maxIndex < freqData.length - 1) {
                    const left = freqData[maxIndex - 1];
                    const center = freqData[maxIndex];
                    const right = freqData[maxIndex + 1];
                    
                    // Parabolic interpolation formula for sub-bin accuracy
                    const delta = 0.5 * (left - right) / (left - 2 * center + right);
                    interpolatedIndex = maxIndex + delta;
                }
                
                // Convert interpolated index to frequency
                const frequency = interpolatedIndex * this.audioContext.sampleRate / (this.analyser.fftSize * 2);
                
                return {
                    index: maxIndex,
                    interpolatedIndex: interpolatedIndex,
                    frequency: frequency,
                    amplitude: maxValue
                };
            }
            

            
            detectGuitarString(frequency) {
                // Guitar string frequencies with optimized ranges for better accuracy
                const guitarStrings = [
                    { string: 6, note: 'E', frequency: 82.41, min: 75, max: 90, weight: 1.0 }, // Low E
                    { string: 5, note: 'A', frequency: 110.00, min: 100, max: 120, weight: 1.0 }, // A
                    { string: 4, note: 'D', frequency: 146.83, min: 135, max: 158, weight: 1.0 }, // D
                    { string: 3, note: 'G', frequency: 196.00, min: 180, max: 212, weight: 1.0 }, // G
                    { string: 2, note: 'B', frequency: 246.94, min: 230, max: 264, weight: 1.0 }, // B
                    { string: 1, note: 'E', frequency: 329.63, min: 310, max: 349, weight: 1.0 }  // High E
                ];
                
                // First, check for exact range matches
                for (const string of guitarStrings) {
                    if (frequency >= string.min && frequency <= string.max) {
                        return string;
                    }
                }
                
                // If no exact range match, use weighted scoring for better accuracy
                let bestMatch = null;
                let bestScore = -Infinity;
                
                for (const string of guitarStrings) {
                    const difference = Math.abs(frequency - string.frequency);
                    const normalizedDifference = difference / string.frequency; // Normalize by target frequency
                    const score = string.weight / (1 + normalizedDifference * 10); // Weighted scoring
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = string;
                    }
                }
                
                return bestMatch;
            }
            
            // Calculate cents deviation from target frequency
            calculateCents(detectedFreq, targetFreq) {
                if (detectedFreq <= 0 || targetFreq <= 0) return 0;
                
                // Cents formula: 1200 * log2(detectedFreq / targetFreq)
                const cents = 1200 * Math.log2(detectedFreq / targetFreq);
                return Math.round(cents);
            }
            
            // Get clean note name without octave for display
            getCleanNoteName(noteName) {
                // Remove octave numbers (E2 -> E, A3 -> A, etc.)
                return noteName.replace(/\d+$/, '');
            }
            
            // Smooth value changes to prevent flickering
            smoothValueChange(element, newValue, oldValue, threshold = 0.1) {
                // Only update if the change is significant enough
                if (Math.abs(newValue - oldValue) > threshold) {
                    element.textContent = newValue;
                    return true; // Value was updated
                }
                return false; // Value was not updated (too small change)
            }
            
            // Filter out non-guitar sounds using multiple criteria
            filterGuitarSounds(freqData, signalStrength) {
                // 1. Check if frequency is in guitar string range (82 Hz - 330 Hz)
                const guitarRange = { min: 75, max: 350 }; // Slightly wider than exact string frequencies
                
                // 2. Analyze harmonic structure (guitar strings have specific harmonics)
                const harmonicAnalysis = this.analyzeHarmonicStructure(freqData);
                
                // 3. Check signal stability (guitar notes are more stable than noise)
                const stabilityAnalysis = this.analyzeSignalStability(freqData);
                
                // 4. Check for guitar-like frequency patterns
                const patternAnalysis = this.analyzeGuitarPatterns(freqData);
                
                // Combine all analyses to determine if this is a guitar sound
                let guitarScore = 0;
                let reasons = [];
                
                // Range check (30% weight)
                if (harmonicAnalysis.fundamentalFreq >= guitarRange.min && 
                    harmonicAnalysis.fundamentalFreq <= guitarRange.max) {
                    guitarScore += 30;
                } else {
                    reasons.push(`Frequency ${harmonicAnalysis.fundamentalFreq.toFixed(1)}Hz outside guitar range`);
                }
                
                // Harmonic structure check (25% weight)
                if (harmonicAnalysis.harmonicQuality > 0.6) {
                    guitarScore += 25;
                } else {
                    reasons.push(`Poor harmonic structure (${harmonicAnalysis.harmonicQuality.toFixed(2)})`);
                }
                
                // Signal stability check (25% weight)
                if (stabilityAnalysis.stability > 0.7) {
                    guitarScore += 25;
                } else {
                    reasons.push(`Unstable signal (${stabilityAnalysis.stability.toFixed(2)})`);
                }
                
                // Pattern analysis check (20% weight)
                if (patternAnalysis.guitarLikelihood > 0.6) {
                    guitarScore += 20;
                } else {
                    reasons.push(`Non-guitar pattern (${patternAnalysis.guitarLikelihood.toFixed(2)})`);
                }
                
                // Determine if this is a guitar sound (need at least 70% score)
                const isGuitar = guitarScore >= 70;
                
                return {
                    isGuitar: isGuitar,
                    score: guitarScore,
                    reason: isGuitar ? 'Guitar sound detected' : reasons.join(', '),
                    details: {
                        harmonic: harmonicAnalysis,
                        stability: stabilityAnalysis,
                        pattern: patternAnalysis
                    }
                };
            }
            
            // Analyze harmonic structure of the audio
            analyzeHarmonicStructure(freqData) {
                const sampleRate = this.audioContext.sampleRate;
                const fftSize = this.analyser.fftSize;
                
                // Find the strongest frequency (fundamental)
                let maxValue = 0;
                let fundamentalFreq = 0;
                let fundamentalIndex = 0;
                
                for (let i = 0; i < freqData.length; i++) {
                    if (freqData[i] > maxValue) {
                        maxValue = freqData[i];
                        fundamentalIndex = i;
                        fundamentalFreq = i * sampleRate / fftSize;
                    }
                }
                
                if (fundamentalFreq === 0) {
                    return { fundamentalFreq: 0, harmonicQuality: 0, harmonics: [] };
                }
                
                // Look for expected harmonics (2x, 3x, 4x, 5x fundamental)
                const expectedHarmonics = [2, 3, 4, 5];
                const harmonics = [];
                let harmonicStrength = 0;
                
                for (const multiplier of expectedHarmonics) {
                    const harmonicFreq = fundamentalFreq * multiplier;
                    const harmonicIndex = Math.floor(harmonicFreq * fftSize / sampleRate);
                    
                    if (harmonicIndex < freqData.length) {
                        const harmonicValue = freqData[harmonicIndex];
                        const tolerance = fundamentalFreq * 0.02; // 2% tolerance
                        
                        // Check if harmonic exists within tolerance
                        if (harmonicValue > maxValue * 0.1) { // At least 10% of fundamental strength
                            harmonics.push({
                                frequency: harmonicFreq,
                                strength: harmonicValue,
                                multiplier: multiplier
                            });
                            harmonicStrength += harmonicValue;
                        }
                    }
                }
                
                // Calculate harmonic quality (how well the harmonics match expected guitar string patterns)
                const harmonicQuality = Math.min(1, harmonicStrength / (maxValue * expectedHarmonics.length * 0.3));
                
                return {
                    fundamentalFreq: fundamentalFreq,
                    harmonicQuality: harmonicQuality,
                    harmonics: harmonics,
                    totalHarmonicStrength: harmonicStrength
                };
            }
            
            // Analyze signal stability (guitar notes are more stable than noise)
            analyzeSignalStability(freqData) {
                const sampleRate = this.audioContext.sampleRate;
                const fftSize = this.analyser.fftSize;
                
                // Calculate frequency centroid (center of mass of the spectrum)
                let weightedSum = 0;
                let totalWeight = 0;
                
                for (let i = 0; i < freqData.length; i++) {
                    const freq = i * sampleRate / fftSize;
                    const weight = freqData[i];
                    weightedSum += freq * weight;
                    totalWeight += weight;
                }
                
                const centroidFreq = totalWeight > 0 ? weightedSum / totalWeight : 0;
                
                // Calculate spectral spread (how spread out the frequencies are)
                let spreadSum = 0;
                for (let i = 0; i < freqData.length; i++) {
                    const freq = i * sampleRate / fftSize;
                    const weight = freqData[i];
                    spreadSum += weight * Math.pow(freq - centroidFreq, 2);
                }
                
                const spectralSpread = totalWeight > 0 ? Math.sqrt(spreadSum / totalWeight) : 0;
                
                // Calculate spectral rolloff (frequency below which 85% of energy is contained)
                let energySum = 0;
                let rolloffFreq = 0;
                
                for (let i = 0; i < freqData.length; i++) {
                    const freq = i * sampleRate / fftSize;
                    const weight = freqData[i];
                    energySum += weight;
                    
                    if (energySum >= totalWeight * 0.85) {
                        rolloffFreq = freq;
                        break;
                    }
                }
                
                // Stability score: lower spread and rolloff indicate more stable, guitar-like sounds
                const spreadScore = Math.max(0, 1 - (spectralSpread / 1000)); // Normalize spread
                const rolloffScore = Math.max(0, 1 - (rolloffFreq / 2000)); // Normalize rolloff
                
                const stability = (spreadScore + rolloffScore) / 2;
                
                return {
                    stability: stability,
                    centroidFreq: centroidFreq,
                    spectralSpread: spectralSpread,
                    spectralRolloff: rolloffFreq
                };
            }
            
            // Analyze frequency patterns to identify guitar-like characteristics
            analyzeGuitarPatterns(freqData) {
                const sampleRate = this.audioContext.sampleRate;
                const fftSize = this.analyser.fftSize;
                
                // Guitar strings have specific frequency relationships
                const guitarStringFreqs = [82.41, 110.00, 146.83, 196.00, 246.94, 329.63];
                
                // Find the strongest frequency
                let maxValue = 0;
                let strongestFreq = 0;
                
                for (let i = 0; i < freqData.length; i++) {
                    if (freqData[i] > maxValue) {
                        maxValue = freqData[i];
                        strongestFreq = i * sampleRate / fftSize;
                    }
                }
                
                if (strongestFreq === 0) {
                    return { guitarLikelihood: 0, closestString: null, frequencyMatch: 0 };
                }
                
                // Check how close the strongest frequency is to any guitar string
                let bestMatch = null;
                let bestMatchScore = 0;
                
                for (const stringFreq of guitarStringFreqs) {
                    const freqDiff = Math.abs(strongestFreq - stringFreq);
                    const matchScore = Math.max(0, 1 - (freqDiff / 10)); // 10 Hz tolerance for better accuracy
                    
                    if (matchScore > bestMatchScore) {
                        bestMatchScore = matchScore;
                        bestMatch = {
                            stringFreq: stringFreq,
                            detectedFreq: strongestFreq,
                            difference: freqDiff,
                            score: matchScore
                        };
                    }
                }
                
                // Check for overtone series (guitar strings have specific overtone patterns)
                const overtoneScore = this.analyzeOvertoneSeries(freqData, strongestFreq);
                
                // Combine frequency match and overtone analysis
                const guitarLikelihood = (bestMatchScore * 0.7) + (overtoneScore * 0.3);
                
                return {
                    guitarLikelihood: guitarLikelihood,
                    closestString: bestMatch,
                    overtoneScore: overtoneScore,
                    strongestFreq: strongestFreq
                };
            }
            
            // Analyze overtone series (guitar strings have specific overtone patterns)
            analyzeOvertoneSeries(freqData, fundamentalFreq) {
                if (fundamentalFreq === 0) return 0;
                
                const sampleRate = this.audioContext.sampleRate;
                const fftSize = this.analyser.fftSize;
                
                // Expected overtone frequencies for guitar strings
                const expectedOvertones = [1, 2, 3, 4, 5, 6];
                let overtoneScore = 0;
                let foundOvertones = 0;
                
                for (const overtone of expectedOvertones) {
                    const overtoneFreq = fundamentalFreq * overtone;
                    const overtoneIndex = Math.floor(overtoneFreq * fftSize / sampleRate);
                    
                    if (overtoneIndex < freqData.length) {
                        const overtoneValue = freqData[overtoneIndex];
                        const tolerance = fundamentalFreq * 0.2; // 2% tolerance
                        
                        // Check if overtone exists and is strong enough
                        if (overtoneValue > 0) {
                            foundOvertones++;
                            // Higher overtones should be progressively weaker
                            const expectedStrength = 1 / overtone; // 1st overtone = 100%, 2nd = 50%, etc.
                            const actualStrength = overtoneValue / freqData[Math.floor(fundamentalFreq * fftSize / sampleRate)];
                            const strengthScore = Math.max(0, 1 - Math.abs(actualStrength - expectedStrength));
                            overtoneScore += strengthScore;
                        }
                    }
                }
                
                // Normalize overtone score
                const normalizedScore = foundOvertones > 0 ? overtoneScore / foundOvertones : 0;
                
                return normalizedScore;
            }
            
            // Reset display to zero after 3-second delay
            resetDisplayToZero() {
                // Clear the last detected values
                this.lastDetectedFrequency = null;
                this.lastDetectedNote = null;
                this.lastDetectedString = null;
                this.frequencyResetTimer = null;
                
                // Reset all displays
                this.noteDisplay.textContent = '--';
                this.frequencyDisplay.textContent = '0 Hz';
                this.tunerNeedle.className = 'tuner-needle';
                this.updateConfidence(0);
                
                // Remove persisted classes
                this.noteDisplay.classList.remove('persisted');
                this.frequencyDisplay.classList.remove('persisted');
                
                // Reset string reference visual state
                this.resetStringReferenceVisual();
                
                console.log('Display reset to zero after 3-second delay');
            }
            
            // Enhanced Low E detection for 6th string accuracy
            enhancedLowEDetection(freqData, initialFrequency) {
                const sampleRate = this.audioContext.sampleRate;
                const fftSize = this.analyser.fftSize;
                const targetFreq = 82.41; // Low E target frequency
                
                // Multi-algorithm approach specifically for Low E
                const results = [];
                
                // 1. Enhanced FFT with sub-bin interpolation
                const fftResult = this.enhancedFFTForLowE(freqData, initialFrequency);
                if (fftResult.confidence > 0.7) {
                    results.push(fftResult);
                }
                
                // 2. Autocorrelation for Low E (very effective for low frequencies)
                const autocorrResult = this.autocorrelationForLowE(freqData, initialFrequency);
                if (autocorrResult.confidence > 0.7) {
                    results.push(autocorrResult);
                }
                
                // 3. Harmonic analysis for Low E
                const harmonicResult = this.lowEHarmonicAnalysis(freqData, initialFrequency);
                if (harmonicResult.confidence > 0.7) {
                    results.push(harmonicResult);
                }
                
                // 4. Pitchy.js for Low E (if available)
                if (window.pitchy) {
                    const pitchyResult = this.pitchyForLowE(freqData, initialFrequency);
                    if (pitchyResult.confidence > 0.7) {
                        results.push(pitchyResult);
                    }
                }
                
                // Select best result based on confidence and proximity to target
                if (results.length === 0) {
                    return { improved: false, frequency: initialFrequency, confidence: 0 };
                }
                
                // Sort by confidence and proximity to Low E target
                results.sort((a, b) => {
                    const aScore = a.confidence * (1 - Math.abs(a.frequency - targetFreq) / 20);
                    const bScore = b.confidence * (1 - Math.abs(b.frequency - targetFreq) / 20);
                    return bScore - aScore;
                });
                
                const bestResult = results[0];
                
                // Only improve if we have significantly better confidence or accuracy
                const improvementThreshold = 0.1; // 10% improvement required
                const currentAccuracy = 1 - Math.abs(initialFrequency - targetFreq) / 20;
                const newAccuracy = 1 - Math.abs(bestResult.frequency - targetFreq) / 20;
                
                if (bestResult.confidence > 0.8 && (newAccuracy - currentAccuracy) > improvementThreshold) {
                    return {
                        improved: true,
                        frequency: bestResult.frequency,
                        confidence: bestResult.confidence,
                        method: bestResult.method
                    };
                }
                
                return { improved: false, frequency: initialFrequency, confidence: 0 };
            }
            
            // Enhanced FFT specifically for Low E detection
            enhancedFFTForLowE(freqData, initialFreq) {
                const sampleRate = this.audioContext.sampleRate;
                const fftSize = this.analyser.fftSize;
                
                // Focus on Low E range with higher resolution
                const lowERange = { min: 70, max: 100 };
                let maxValue = 0;
                let bestFreq = initialFreq;
                let confidence = 0;
                
                // Search in the Low E range with sub-bin precision
                for (let i = 0; i < freqData.length; i++) {
                    const freq = i * sampleRate / fftSize;
                    
                    if (freq >= lowERange.min && freq <= lowERange.max) {
                        const value = freqData[i];
                        
                        if (value > maxValue) {
                            maxValue = value;
                            bestFreq = freq;
                        }
                    }
                }
                
                // Apply parabolic interpolation for sub-bin accuracy
                if (maxValue > 0) {
                    const interpolatedFreq = this.parabolicInterpolationForLowE(freqData, bestFreq, sampleRate, fftSize);
                    bestFreq = interpolatedFreq;
                }
                
                // Calculate confidence based on signal strength and proximity to target
                const targetFreq = 82.41;
                const freqAccuracy = 1 - Math.abs(bestFreq - targetFreq) / 20;
                const signalStrength = maxValue / 255;
                confidence = (freqAccuracy * 0.6) + (signalStrength * 0.4);
                
                return {
                    frequency: bestFreq,
                    confidence: confidence,
                    method: 'enhanced-fft-low-e'
                };
            }
            
            // Autocorrelation specifically optimized for Low E
            autocorrelationForLowE(freqData, initialFreq) {
                const sampleRate = this.audioContext.sampleRate;
                const fftSize = this.analyser.fftSize;
                
                // Convert frequency data to time domain for autocorrelation
                const timeData = new Float32Array(fftSize);
                this.analyser.getFloatTimeDomainData(timeData);
                
                // Focus on Low E range (82.41 Hz = ~12ms period)
                const maxLag = Math.floor(sampleRate / 70); // 70 Hz minimum
                const minLag = Math.floor(sampleRate / 100); // 100 Hz maximum
                
                let bestCorrelation = 0;
                let bestFreq = initialFreq;
                
                for (let lag = minLag; lag <= maxLag; lag++) {
                    let correlation = 0;
                    let normalization = 0;
                    
                    for (let i = 0; i < timeData.length - lag; i++) {
                        correlation += timeData[i] * timeData[i + lag];
                        normalization += timeData[i] * timeData[i];
                    }
                    
                    if (normalization > 0) {
                        correlation = correlation / normalization;
                        
                        if (correlation > bestCorrelation) {
                            bestCorrelation = correlation;
                            bestFreq = sampleRate / lag;
                        }
                    }
                }
                
                // Calculate confidence
                const targetFreq = 82.41;
                const freqAccuracy = 1 - Math.abs(bestFreq - targetFreq) / 20;
                const correlationStrength = bestCorrelation;
                const confidence = (freqAccuracy * 0.7) + (correlationStrength * 0.3);
                
                return {
                    frequency: bestFreq,
                    confidence: confidence,
                    method: 'autocorr-low-e'
                };
            }
            
            // Harmonic analysis specifically for Low E
            lowEHarmonicAnalysis(freqData, initialFreq) {
                const sampleRate = this.audioContext.sampleRate;
                const fftSize = this.analyser.fftSize;
                const targetFreq = 82.41;
                
                // Low E harmonics: 82.41, 164.82, 247.23, 329.64, 412.05 Hz
                const expectedHarmonics = [1, 2, 3, 4, 5];
                let harmonicScore = 0;
                let totalHarmonics = 0;
                
                for (const harmonic of expectedHarmonics) {
                    const harmonicFreq = targetFreq * harmonic;
                    const harmonicIndex = Math.floor(harmonicFreq * fftSize / sampleRate);
                    
                    if (harmonicIndex < freqData.length) {
                        const harmonicValue = freqData[harmonicIndex];
                        const tolerance = targetFreq * 0.02; // 2% tolerance
                        
                        if (harmonicValue > 0) {
                            totalHarmonics++;
                            // Check if harmonic exists within tolerance
                            const freqDiff = Math.abs(harmonicFreq - (harmonicIndex * sampleRate / fftSize));
                            if (freqDiff <= tolerance) {
                                harmonicScore += harmonicValue / 255;
                            }
                        }
                    }
                }
                
                // Calculate confidence based on harmonic strength and fundamental proximity
                const fundamentalIndex = Math.floor(targetFreq * fftSize / sampleRate);
                const fundamentalValue = freqData[fundamentalIndex] / 255;
                const harmonicConfidence = totalHarmonics > 0 ? harmonicScore / totalHarmonics : 0;
                
                // Weight fundamental more heavily for Low E
                const confidence = (fundamentalValue * 0.8) + (harmonicConfidence * 0.2);
                
                return {
                    frequency: targetFreq, // Return target frequency for Low E
                    confidence: confidence,
                    method: 'harmonic-low-e'
                };
            }
            
            // Pitchy.js specifically for Low E detection
            pitchyForLowE(freqData, initialFreq) {
                if (!window.pitchy) {
                    return { frequency: initialFreq, confidence: 0, method: 'pitchy-unavailable' };
                }
                
                const sampleRate = this.audioContext.sampleRate;
                const fftSize = this.analyser.fftSize;
                
                // Get time domain data for Pitchy.js
                const timeData = new Float32Array(fftSize);
                this.analyser.getFloatTimeDomainData(timeData);
                
                try {
                    const [frequency, clarity] = window.pitchy.findPitch(timeData, sampleRate);
                    
                    // Only use if frequency is in Low E range and clarity is good
                    if (frequency >= 70 && frequency <= 100 && clarity > 0.7) {
                        const targetFreq = 82.41;
                        const freqAccuracy = 1 - Math.abs(frequency - targetFreq) / 20;
                        const confidence = (freqAccuracy * 0.6) + (clarity * 0.4);
                        
                        return {
                            frequency: frequency,
                            confidence: confidence,
                            method: 'pitchy-low-e'
                        };
                    }
                } catch (error) {
                    console.log('Pitchy.js error for Low E:', error);
                }
                
                return { frequency: initialFreq, confidence: 0, method: 'pitchy-failed' };
            }
            
            // Parabolic interpolation for sub-bin accuracy in Low E detection
            parabolicInterpolationForLowE(freqData, peakFreq, sampleRate, fftSize) {
                const peakIndex = Math.floor(peakFreq * fftSize / sampleRate);
                
                if (peakIndex <= 0 || peakIndex >= freqData.length - 1) {
                    return peakFreq;
                }
                
                const left = freqData[peakIndex - 1];
                const center = freqData[peakIndex];
                const right = freqData[peakIndex + 1];
                
                if (left === 0 || right === 0) {
                    return peakFreq;
                }
                
                // Parabolic interpolation formula
                const offset = 0.5 * (left - right) / (left - 2 * center + right);
                const interpolatedIndex = peakIndex + offset;
                const interpolatedFreq = interpolatedIndex * sampleRate / fftSize;
                
                return interpolatedFreq;
            }
            
            // Update string reference visual state based on detection
            updateStringReferenceVisual(result) {
                // Clear all previous visual states
                const allStringItems = document.querySelectorAll('.string-item');
                allStringItems.forEach(item => {
                    item.classList.remove('detected', 'in-tune', 'sharp', 'flat');
                });
                
                // If a string was detected, highlight it
                if (result.string) {
                    const stringItem = document.querySelector(`[data-string="${result.string}"]`);
                    if (stringItem) {
                        // Add appropriate tuning class
                        if (Math.abs(result.cents) <= 50) { // 50 cents = in tune (25Hz tolerance)
                            stringItem.classList.add('in-tune');
                        } else if (result.cents > 0) {
                            stringItem.classList.add('sharp');
                        } else {
                            stringItem.classList.add('flat');
                        }
                    }
                }
            }
            
            // Reset string reference visual state
            resetStringReferenceVisual() {
                const allStringItems = document.querySelectorAll('.string-item');
                allStringItems.forEach(item => {
                    item.classList.remove('detected', 'in-tune', 'sharp', 'flat');
                });
            }
            
            frequencyToNote(frequency) {
                // Comprehensive note detection covering full guitar range (82 Hz - 330 Hz)
                // Using scientific pitch notation with octave numbers
                const notes = [
                    // Low E (6th string) and below
                    { name: 'E2', frequency: 82.41, octave: 2 },
                    { name: 'F2', frequency: 87.31, octave: 2 },
                    { name: 'F#2', frequency: 92.50, octave: 2 },
                    { name: 'G2', frequency: 98.00, octave: 2 },
                    { name: 'G#2', frequency: 103.83, octave: 2 },
                    { name: 'A2', frequency: 110.00, octave: 2 }, // 5th string
                    { name: 'A#2', frequency: 116.54, octave: 2 },
                    { name: 'B2', frequency: 123.47, octave: 2 },
                    
                    // D and G strings (4th and 3rd)
                    { name: 'C3', frequency: 130.81, octave: 3 },
                    { name: 'C#3', frequency: 138.59, octave: 3 },
                    { name: 'D3', frequency: 146.83, octave: 3 }, // 4th string
                    { name: 'D#3', frequency: 155.56, octave: 3 },
                    { name: 'E3', frequency: 164.81, octave: 3 },
                    { name: 'F3', frequency: 174.61, octave: 3 },
                    { name: 'F#3', frequency: 185.00, octave: 3 },
                    { name: 'G3', frequency: 196.00, octave: 3 }, // 3rd string
                    { name: 'G#3', frequency: 207.65, octave: 3 },
                    { name: 'A3', frequency: 220.00, octave: 3 },
                    { name: 'A#3', frequency: 233.08, octave: 3 },
                    { name: 'B3', frequency: 246.94, octave: 3 }, // 2nd string
                    
                    // High E (1st string) and above
                    { name: 'C4', frequency: 261.63, octave: 4 },
                    { name: 'C#4', frequency: 277.18, octave: 4 },
                    { name: 'D4', frequency: 293.66, octave: 4 },
                    { name: 'D#4', frequency: 311.13, octave: 4 },
                    { name: 'E4', frequency: 329.63, octave: 4 }, // 1st string
                    { name: 'F4', frequency: 349.23, octave: 4 },
                    { name: 'F#4', frequency: 369.99, octave: 4 },
                    { name: 'G4', frequency: 392.00, octave: 4 },
                    { name: 'G#4', frequency: 415.30, octave: 4 },
                    { name: 'A4', frequency: 440.00, octave: 4 },
                    { name: 'A#4', frequency: 466.16, octave: 4 },
                    { name: 'B4', frequency: 493.88, octave: 4 }
                ];
                
                // Find the closest note
                let closestNote = notes[0];
                let minDifference = Math.abs(frequency - notes[0].frequency);
                
                for (let note of notes) {
                    const difference = Math.abs(frequency - note.frequency);
                    if (difference < minDifference) {
                        minDifference = difference;
                        closestNote = note;
                    }
                }
                
                // Return note name without octave for cleaner display
                return { name: closestNote.name, frequency: closestNote.frequency };
            }
            
            findFrequencyPeaks(freqData) {
                // Multi-algorithm fusion for maximum accuracy
                const peaks = [];
                
                // Get time domain data
                const timeData = new Float32Array(this.analyser.fftSize);
                this.analyser.getFloatTimeDomainData(timeData);
                
                // 1. YIN Algorithm (Most Accurate)
                const yinResult = this.yinPitchDetection(timeData);
                if (yinResult.frequency > 0 && yinResult.confidence > 0.7) {
                    peaks.push({
                        index: Math.floor(yinResult.frequency * this.analyser.fftSize / this.audioContext.sampleRate),
                        frequency: yinResult.frequency,
                        amplitude: yinResult.confidence * 255,
                        confidence: yinResult.confidence,
                        method: 'yin'
                    });
                }
                
                // 2. AMDF Algorithm (Excellent Noise Resistance)
                const amdfResult = this.amdfPitchDetection(timeData);
                if (amdfResult.frequency > 0 && amdfResult.confidence > 0.6) {
                    peaks.push({
                        index: Math.floor(amdfResult.frequency * this.analyser.fftSize / this.audioContext.sampleRate),
                        frequency: amdfResult.frequency,
                        amplitude: amdfResult.confidence * 255,
                        confidence: amdfResult.confidence,
                        method: 'amdf'
                    });
                }
                
                // 3. Harmonic Product Spectrum (Best for Complex Waveforms)
                const hpsResult = this.harmonicProductSpectrum(freqData);
                if (hpsResult.frequency > 0 && hpsResult.confidence > 0.5) {
                    peaks.push({
                        index: Math.floor(hpsResult.frequency * this.analyser.fftSize / this.audioContext.sampleRate),
                        frequency: hpsResult.frequency,
                        amplitude: hpsResult.confidence * 255,
                        confidence: hpsResult.confidence,
                        method: 'hps'
                    });
                }
                
                // 4. Pitchy.js as backup
                if (window.pitchy && peaks.length === 0) {
                    try {
                        const [pitch, clarity] = window.pitchy.findPitch(timeData, this.audioContext.sampleRate);
                        if (pitch > 0 && clarity > 0.5) {
                            peaks.push({
                                index: Math.floor(pitch * this.analyser.fftSize / this.audioContext.sampleRate),
                                frequency: pitch,
                                amplitude: clarity * 255,
                                confidence: clarity,
                                method: 'pitchy'
                            });
                        }
                    } catch (error) {
                        console.log('Pitchy.js error:', error);
                    }
                }
                
                // 5. FFT as final fallback
                if (peaks.length === 0) {
                    const fftResult = this.findStrongestFFT(freqData);
                    if (fftResult.frequency > 0) {
                        peaks.push({
                            index: fftResult.index,
                            frequency: fftResult.frequency,
                            amplitude: fftResult.amplitude,
                            confidence: fftResult.confidence,
                            method: 'fft'
                        });
                    }
                }
                
                // Sort by confidence and remove duplicates
                peaks.sort((a, b) => b.confidence - a.confidence);
                return this.removeDuplicateFrequencies(peaks);
            }
            
            findFundamentalFrequency(peaks) {
                if (peaks.length === 0) return null;
                
                // Start with the strongest peak
                let fundamental = peaks[0].frequency;
                
                // Check if any lower frequency peak could be the fundamental
                for (let i = 1; i < peaks.length; i++) {
                    const peak = peaks[i];
                    
                    // If this peak is significantly lower and strong enough, it might be fundamental
                    if (peak.frequency < fundamental * 0.8 && peak.amplitude > peaks[0].amplitude * 0.3) {
                        fundamental = peak.frequency;
                    }
                }
                
                return fundamental;
            }
            
            calculateHarmonicQuality(peaks, fundamentalFreq) {
                if (peaks.length < 2) return 50; // Neutral score for single peak
                
                let harmonicScore = 0;
                let validHarmonics = 0;
                
                // Check for harmonic relationships (2x, 3x, 4x, etc.)
                for (let i = 1; i < peaks.length; i++) {
                    const peak = peaks[i];
                    const ratio = peak.frequency / fundamentalFreq;
                    
                    // Check if this peak is close to a harmonic
                    const nearestHarmonic = Math.round(ratio);
                    const harmonicError = Math.abs(ratio - nearestHarmonic);
                    
                    if (harmonicError < 0.1 && nearestHarmonic >= 2 && nearestHarmonic <= 6) {
                        harmonicScore += (1 - harmonicError) * 100;
                        validHarmonics++;
                    }
                }
                
                return validHarmonics > 0 ? harmonicScore / validHarmonics : 50;
            }
            
            // Frequency smoothing for more stable readings
            smoothFrequency(newFrequency) {
                if (!this.frequencyHistory) {
                    this.frequencyHistory = [];
                }
                
                // Add new frequency to history
                this.frequencyHistory.push(newFrequency);
                
                // Keep only last 5 readings for smoothing
                if (this.frequencyHistory.length > 5) {
                    this.frequencyHistory.shift();
                }
                
                // Use median for more stable readings (less affected by outliers)
                const sorted = [...this.frequencyHistory].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                
                if (sorted.length % 2 === 0) {
                    return (sorted[mid - 1] + sorted[mid]) / 2;
                } else {
                    return sorted[mid];
                }
            }
            
            // Simplified autocorrelation for reliable frequency detection
            autocorrelate(timeData, minFreq, maxFreq) {
                const sampleRate = this.audioContext.sampleRate;
                const minPeriod = Math.floor(sampleRate / maxFreq);
                const maxPeriod = Math.floor(sampleRate / minFreq);
                
                let bestLag = 0;
                let bestCorrelation = 0;
                
                // Calculate autocorrelation for different lags
                for (let lag = minPeriod; lag <= maxPeriod; lag++) {
                    let correlation = 0;
                    let count = 0;
                    
                    // Calculate correlation for this lag
                    for (let i = 0; i < timeData.length - lag; i++) {
                        correlation += timeData[i] * timeData[i + lag];
                        count++;
                    }
                    
                    if (count > 0) {
                        correlation /= count;
                        
                        // Normalize by the autocorrelation at lag 0
                        const autocorr0 = this.calculateAutocorr0(timeData);
                        if (autocorr0 > 0) {
                            correlation /= autocorr0;
                        }
                        
                        if (correlation > bestCorrelation) {
                            bestCorrelation = correlation;
                            bestLag = lag;
                        }
                    }
                }
                
                if (bestCorrelation > 0.2) { // Lower threshold for better detection
                    const frequency = sampleRate / bestLag;
                    
                    return {
                        frequency: frequency,
                        confidence: bestCorrelation,
                        lag: bestLag
                    };
                }
                
                return { frequency: 0, confidence: 0, lag: 0 };
            }
            
            calculateAutocorr0(timeData) {
                let sum = 0;
                for (let i = 0; i < timeData.length; i++) {
                    sum += timeData[i] * timeData[i];
                }
                return sum / timeData.length;
            }
            
            // Phase vocoder for sub-sample frequency accuracy
            refineFrequencyWithPhase(timeData, lag, sampleRate) {
                if (lag <= 0) return sampleRate / lag;
                
                // Calculate phase difference between samples
                let phaseSum = 0;
                let count = 0;
                
                for (let i = 0; i < timeData.length - lag; i++) {
                    const current = timeData[i];
                    const next = timeData[i + lag];
                    
                    if (Math.abs(current) > 0.01 && Math.abs(next) > 0.01) {
                        // Calculate phase using atan2 for better numerical stability
                        const phase = Math.atan2(next, current);
                        phaseSum += phase;
                        count++;
                    }
                }
                
                if (count > 0) {
                    const avgPhase = phaseSum / count;
                    
                    // Refine the frequency using phase information
                    const phaseCorrection = avgPhase / (2 * Math.PI);
                    const refinedLag = lag + phaseCorrection;
                    
                    if (refinedLag > 0) {
                        return sampleRate / refinedLag;
                    }
                }
                
                // Fallback to basic frequency calculation
                return sampleRate / lag;
            }
            
            // YIN Algorithm - Most accurate pitch detection method
            yinPitchDetection(timeData) {
                const sampleRate = this.audioContext.sampleRate;
                const minFreq = 20; // Extended range for better detection
                const maxFreq = 2000; // Extended range for better detection
                const minPeriod = Math.floor(sampleRate / maxFreq);
                const maxPeriod = Math.floor(sampleRate / minFreq);
                
                // Step 1: Difference function with improved numerical stability
                const diff = new Float32Array(maxPeriod + 1);
                for (let t = 0; t <= maxPeriod; t++) {
                    diff[t] = 0;
                    let count = 0;
                    for (let i = 0; i < timeData.length - t; i++) {
                        const delta = timeData[i] - timeData[i + t];
                        diff[t] += delta * delta;
                        count++;
                    }
                    if (count > 0) diff[t] /= count; // Normalize
                }
                
                // Step 2: Cumulative mean normalized difference
                const cmnd = new Float32Array(maxPeriod + 1);
                cmnd[0] = 1;
                let runningSum = 0;
                
                for (let t = 1; t <= maxPeriod; t++) {
                    runningSum += diff[t];
                    cmnd[t] = diff[t] / (runningSum / t);
                }
                
                // Step 3: Adaptive threshold based on signal quality
                const signalQuality = this.calculateSignalQuality(timeData);
                const threshold = Math.max(0.05, Math.min(0.2, 0.1 + (1 - signalQuality) * 0.1));
                
                let minTau = 0;
                let minVal = 1000;
                
                for (let t = minPeriod; t <= maxPeriod; t++) {
                    if (cmnd[t] < threshold) {
                        // Find the local minimum with improved search
                        let localMin = t;
                        while (t + 1 <= maxPeriod && cmnd[t + 1] < cmnd[localMin]) {
                            t++;
                            if (cmnd[t] < cmnd[localMin]) localMin = t;
                        }
                        
                        if (cmnd[localMin] < minVal) {
                            minVal = cmnd[localMin];
                            minTau = localMin;
                        }
                    }
                }
                
                if (minTau > 0) {
                    // Step 4: Enhanced parabolic interpolation
                    const refinedTau = this.enhancedParabolicInterpolation(cmnd, minTau);
                    const frequency = sampleRate / refinedTau;
                    
                    // Validate frequency range
                    if (frequency >= minFreq && frequency <= maxFreq) {
                        return {
                            frequency: frequency,
                            confidence: Math.max(0, 1 - minVal),
                            tau: refinedTau
                        };
                    }
                }
                
                return { frequency: 0, confidence: 0, tau: 0 };
            }
            
            // AMDF Algorithm - Excellent noise resistance and accuracy
            amdfPitchDetection(timeData) {
                const sampleRate = this.audioContext.sampleRate;
                const minFreq = 20;
                const maxFreq = 2000;
                const minPeriod = Math.floor(sampleRate / maxFreq);
                const maxPeriod = Math.floor(sampleRate / minFreq);
                
                let bestLag = 0;
                let bestScore = Infinity;
                
                // Calculate AMDF for different lags
                for (let lag = minPeriod; lag <= maxPeriod; lag++) {
                    let amdf = 0;
                    let count = 0;
                    
                    for (let i = 0; i < timeData.length - lag; i++) {
                        amdf += Math.abs(timeData[i] - timeData[i + lag]);
                        count++;
                    }
                    
                    if (count > 0) {
                        amdf /= count; // Normalize
                        
                        // Apply bias correction for better accuracy
                        const biasCorrection = 1 + (lag / sampleRate) * 0.1;
                        amdf *= biasCorrection;
                        
                        if (amdf < bestScore) {
                            bestScore = amdf;
                            bestLag = lag;
                        }
                    }
                }
                
                if (bestLag > 0) {
                    const frequency = sampleRate / bestLag;
                    
                    // Validate frequency range
                    if (frequency >= minFreq && frequency <= maxFreq) {
                        // Calculate confidence based on AMDF score
                        const maxPossibleAmdf = this.calculateMaxPossibleAMDF(timeData);
                        const confidence = Math.max(0, 1 - (bestScore / maxPossibleAmdf));
                        
                        return {
                            frequency: frequency,
                            confidence: confidence,
                            lag: bestLag
                        };
                    }
                }
                
                return { frequency: 0, confidence: 0, lag: 0 };
            }
            
            calculateMaxPossibleAMDF(timeData) {
                let max = 0;
                for (let i = 0; i < timeData.length; i++) {
                    max = Math.max(max, Math.abs(timeData[i]));
                }
                return max * 2;
            }
            
            // Harmonic Product Spectrum - Best for complex waveforms
            harmonicProductSpectrum(freqData) {
                const sampleRate = this.audioContext.sampleRate;
                const minFreq = 20;
                const maxFreq = 2000;
                const minBin = Math.floor(minFreq * this.analyser.fftSize / sampleRate);
                const maxBin = Math.floor(maxFreq * this.analyser.fftSize / sampleRate);
                
                let bestBin = 0;
                let bestScore = -Infinity;
                
                // Apply HPS algorithm
                for (let bin = minBin; bin <= maxBin; bin++) {
                    let hps = 1;
                    let validHarmonics = 0;
                    
                    // Multiply harmonics (2x, 3x, 4x, 5x)
                    for (let harmonic = 1; harmonic <= 5; harmonic++) {
                        const harmonicBin = Math.floor(bin * harmonic);
                        if (harmonicBin < freqData.length && freqData[harmonicBin] > 0) {
                            hps *= freqData[harmonicBin];
                            validHarmonics++;
                        }
                    }
                    
                    if (validHarmonics >= 3) { // Need at least 3 harmonics
                        // Apply frequency weighting for better accuracy
                        const frequency = bin * sampleRate / this.analyser.fftSize;
                        const weight = 1 / (1 + Math.abs(frequency - 440) / 440); // A4 reference
                        const score = hps * weight;
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestBin = bin;
                        }
                    }
                }
                
                if (bestBin > 0) {
                    const frequency = bestBin * sampleRate / this.analyser.fftSize;
                    
                    // Calculate confidence based on harmonic strength
                    const confidence = Math.min(1.0, bestScore / 1000000);
                    
                    return {
                        frequency: frequency,
                        confidence: confidence,
                        bin: bestBin
                    };
                }
                
                return { frequency: 0, confidence: 0, bin: 0 };
            }
            
            parabolicInterpolation(array, index) {
                if (index <= 0 || index >= array.length - 1) return index;
                
                const left = array[index - 1];
                const center = array[index];
                const right = array[index + 1];
                
                const delta = 0.5 * (left - right) / (left - 2 * center + right);
                return index + delta;
            }
            
            // Enhanced parabolic interpolation with validation
            enhancedParabolicInterpolation(array, index) {
                if (index <= 0 || index >= array.length - 1) return index;
                
                const left = array[index - 1];
                const center = array[index];
                const right = array[index + 1];
                
                // Check for numerical stability
                if (Math.abs(left - 2 * center + right) < 1e-10) return index;
                
                const delta = 0.5 * (left - right) / (left - 2 * center + right);
                
                // Validate the result
                if (Math.abs(delta) < 1.0) {
                    return index + delta;
                }
                
                return index;
            }
            
            // Calculate signal quality for adaptive thresholds
            calculateSignalQuality(timeData) {
                let sum = 0;
                let count = 0;
                
                for (let i = 0; i < timeData.length; i++) {
                    sum += Math.abs(timeData[i]);
                    count++;
                }
                
                const avgAmplitude = sum / count;
                const maxAmplitude = Math.max(...Array.from(timeData).map(Math.abs));
                
                return Math.min(1.0, avgAmplitude / maxAmplitude);
            }
            
            // Find strongest FFT frequency
            findStrongestFFT(freqData) {
                let maxIndex = 0;
                let maxValue = 0;
                
                for (let i = 0; i < freqData.length; i++) {
                    if (freqData[i] > maxValue) {
                        maxValue = freqData[i];
                        maxIndex = i;
                    }
                }
                
                const frequency = maxIndex * this.audioContext.sampleRate / (this.analyser.fftSize * 2);
                
                return {
                    index: maxIndex,
                    frequency: frequency,
                    amplitude: maxValue,
                    confidence: maxValue / 255
                };
            }
            
            // Remove duplicate frequencies and merge similar ones
            removeDuplicateFrequencies(peaks) {
                const merged = [];
                const tolerance = 0.5; // 0.5 Hz tolerance
                
                for (const peak of peaks) {
                    let merged = false;
                    
                    for (let i = 0; i < merged.length; i++) {
                        if (Math.abs(peak.frequency - merged[i].frequency) < tolerance) {
                            // Merge similar frequencies, keep the one with higher confidence
                            if (peak.confidence > merged[i].confidence) {
                                merged[i] = peak;
                            }
                            merged = true;
                            break;
                        }
                    }
                    
                    if (!merged) {
                        merged.push(peak);
                    }
                }
                
                return merged;
            }
            
            // Hybrid Professional-Grade Detection (combines best open-source methods)
            async findFrequencySimple(freqData) {
                const sampleRate = this.audioContext.sampleRate;
                const fftSize = this.analyser.fftSize;
                
                // Special Method 0: Low-Frequency Bass Detection (specifically for 6th string E)
                let bassResult = { frequency: 0, confidence: 0, method: 'none' };
                try {
                    bassResult = this.enhancedBassDetection(freqData, sampleRate, fftSize);
                } catch (error) {
                    console.log('Bass detection failed:', error.message);
                }
                
                // Method 1: Pitchy.js (YIN algorithm) - Best for clean signals
                let pitchyResult = { frequency: 0, confidence: 0, method: 'none' };
                try {
                    if (window.pitchy && window.pitchy.findPitch) {
                        const timeData = new Float32Array(this.analyser.frequencyBinCount);
                        this.analyser.getFloatTimeDomainData(timeData);
                        
                        const [pitch, clarity] = window.pitchy.findPitch(timeData, sampleRate);
                        if (pitch > 0 && clarity > 0.8) {
                            pitchyResult = {
                                frequency: pitch,
                                confidence: clarity,
                                method: 'pitchy-yin'
                            };
                        }
                    }
                } catch (error) {
                    console.log('Pitchy.js failed:', error.message);
                }
                
                // Method 2: ML5.js (Machine Learning) - Best for complex audio
                let ml5Result = { frequency: 0, confidence: 0, method: 'none' };
                try {
                    if (window.ml5 && window.ml5.soundClassifier) {
                        // ML5.js audio analysis (if available)
                        ml5Result = {
                            frequency: 0, // Placeholder for ML5 implementation
                            confidence: 0,
                            method: 'ml5-ml'
                        };
                    }
                } catch (error) {
                    console.log('ML5.js failed:', error.message);
                }
                
                // Method 3: Enhanced FFT with TensorFlow.js - Best for raw frequency analysis
                let tfResult = { frequency: 0, confidence: 0, method: 'none' };
                try {
                    if (window.tf) {
                        tfResult = this.enhancedFFTWithTensorFlow(freqData, sampleRate, fftSize);
                    }
                } catch (error) {
                    console.log('TensorFlow.js failed:', error.message);
                }
                
                // Method 4: Fallback to balanced FFT
                const fallbackResult = this.balancedFFTDetection(freqData, sampleRate, fftSize);
                
                // Combine all results and pick the best one
                // Give extra weight to bass detection for low frequencies
                const allResults = [bassResult, pitchyResult, ml5Result, tfResult, fallbackResult]
                    .filter(r => r.frequency > 0 && r.confidence > 0);
                
                if (allResults.length === 0) {
                    return { frequency: 0, confidence: 0, method: 'none' };
                }
                
                // Enhanced selection: prioritize bass detection for low frequencies
                const bestResult = this.selectBestResult(allResults);
                
                console.log('Hybrid detection results:', {
                    bass: bassResult,
                    pitchy: pitchyResult,
                    ml5: ml5Result,
                    tensorflow: tfResult,
                    fallback: fallbackResult,
                    selected: bestResult
                });
                
                return bestResult;
            }
            
            // Enhanced Bass Detection (specifically for 6th string E - 82.41 Hz)
            enhancedBassDetection(freqData, sampleRate, fftSize) {
                try {
                    // Focus on bass frequencies (20-200 Hz) where 6th string E (82.41 Hz) lives
                    const bassMinFreq = 20;
                    const bassMaxFreq = 200;
                    
                    const minBin = Math.floor(bassMinFreq * fftSize / sampleRate);
                    const maxBin = Math.floor(bassMaxFreq * fftSize / sampleRate);
                    
                    let maxIndex = 0;
                    let maxValue = 0;
                    let totalEnergy = 0;
                    let peakCount = 0;
                    
                    // Find the strongest frequency in bass range
                    for (let i = minBin; i <= maxBin && i < freqData.length; i++) {
                        if (freqData[i] > maxValue) {
                            maxValue = freqData[i];
                            maxIndex = i;
                        }
                        
                        // Calculate total energy in bass range
                        if (freqData[i] > 10) {
                            totalEnergy += freqData[i];
                            peakCount++;
                        }
                    }
                    
                    // Convert to frequency
                    const frequency = maxIndex * sampleRate / fftSize;
                    
                    // Enhanced confidence calculation for bass
                    const averageEnergy = peakCount > 0 ? totalEnergy / peakCount : 0;
                    const bassConfidence = Math.min(1.0, (maxValue / 255) * (averageEnergy / 100));
                    
                    // Special handling for 6th string E (82.41 Hz Â± 5 Hz)
                    if (frequency >= 77 && frequency <= 87) {
                        // Boost confidence for the target frequency range
                        const boostedConfidence = Math.min(1.0, bassConfidence * 1.5);
                        
                        console.log(`ðŸŽ¸ Bass detection: ${frequency.toFixed(1)} Hz (6th string E range) - Confidence: ${boostedConfidence.toFixed(3)}`);
                        
                        return {
                            frequency: frequency,
                            confidence: boostedConfidence,
                            method: 'enhanced-bass-detection'
                        };
                    }
                    
                    // Regular bass detection for other low frequencies
                    if (maxValue > 15 && bassConfidence > 0.1) {
                        console.log(`ðŸŽµ Bass detection: ${frequency.toFixed(1)} Hz - Confidence: ${bassConfidence.toFixed(3)}`);
                        
                        return {
                            frequency: frequency,
                            confidence: bassConfidence,
                            method: 'enhanced-bass-detection'
                        };
                    }
                    
                } catch (error) {
                    console.log('Enhanced bass detection failed:', error.message);
                }
                
                return { frequency: 0, confidence: 0, method: 'none' };
            }
            
            // Enhanced result selection that prioritizes bass detection for low frequencies
            selectBestResult(allResults) {
                if (allResults.length === 0) {
                    return { frequency: 0, confidence: 0, method: 'none' };
                }
                
                // Special priority for bass detection in low frequency ranges
                const bassResults = allResults.filter(r => 
                    r.method === 'enhanced-bass-detection' && r.frequency <= 200
                );
                
                if (bassResults.length > 0) {
                    // For bass frequencies, prioritize enhanced bass detection
                    const bestBass = bassResults.reduce((best, current) => 
                        current.confidence > best.confidence ? current : best
                    );
                    
                    // Only use bass detection if it's significantly confident
                    if (bestBass.confidence > 0.3) {
                        console.log(`ðŸŽ¸ Using enhanced bass detection: ${bestBass.frequency.toFixed(1)} Hz`);
                        return bestBass;
                    }
                }
                
                // For all other cases, use the highest confidence result
                const bestResult = allResults.reduce((best, current) => 
                    current.confidence > best.confidence ? current : best
                );
                
                console.log(`ðŸŽ¯ Using ${bestResult.method}: ${bestResult.frequency.toFixed(1)} Hz`);
                return bestResult;
            }
            
            // Enhanced FFT with TensorFlow.js for better frequency resolution
            enhancedFFTWithTensorFlow(freqData, sampleRate, fftSize) {
                try {
                    // Convert to TensorFlow tensor
                    const tensor = window.tf.tensor(freqData);
                    
                    // Apply advanced signal processing
                    const smoothed = tensor.smooth(3); // 3-point smoothing
                    const normalized = smoothed.div(smoothed.max());
                    
                    // Find peaks with higher precision
                    const peaks = this.findPeaksWithTensorFlow(normalized);
                    
                    if (peaks.length > 0) {
                        const bestPeak = peaks[0];
                        const frequency = bestPeak.index * sampleRate / fftSize;
                        
                        return {
                            frequency: frequency,
                            confidence: bestPeak.value,
                            method: 'tensorflow-enhanced-fft'
                        };
                    }
                    
                    tensor.dispose();
                    smoothed.dispose();
                    normalized.dispose();
                } catch (error) {
                    console.log('TensorFlow processing failed:', error.message);
                }
                
                return { frequency: 0, confidence: 0, method: 'none' };
            }
            
            // Find peaks using TensorFlow.js for better accuracy
            findPeaksWithTensorFlow(tensor) {
                try {
                    // Find local maxima
                    const peaks = [];
                    const data = tensor.dataSync();
                    
                    for (let i = 1; i < data.length - 1; i++) {
                        if (data[i] > data[i-1] && data[i] > data[i+1] && data[i] > 0.1) {
                            peaks.push({
                                index: i,
                                value: data[i]
                            });
                        }
                    }
                    
                    // Sort by value (highest first)
                    peaks.sort((a, b) => b.value - a.value);
                    
                    return peaks;
                } catch (error) {
                    console.log('Peak finding failed:', error.message);
                    return [];
                }
            }
            
            // Fallback to balanced FFT detection
            balancedFFTDetection(freqData, sampleRate, fftSize) {
                const lowFreqRange = { min: 20, max: 200 };
                const midFreqRange = { min: 200, max: 2000 };
                const highFreqRange = { min: 2000, max: 20000 };
                
                const lowFreq = this.findStrongestInRange(freqData, lowFreqRange, sampleRate, fftSize);
                const midFreq = this.findStrongestInRange(freqData, midFreqRange, sampleRate, fftSize);
                const highFreq = this.findStrongestInRange(freqData, highFreqRange, sampleRate, fftSize);
                
                const frequencies = [
                    { freq: lowFreq, method: 'low-freq-balanced' },
                    { freq: midFreq, method: 'mid-freq-balanced' },
                    { freq: highFreq, method: 'high-freq-balanced' }
                ].filter(f => f.freq.frequency > 0);
                
                if (frequencies.length === 0) {
                    return { frequency: 0, confidence: 0, method: 'none' };
                }
                
                const bestFrequency = frequencies.reduce((best, current) => 
                    current.freq.confidence > best.freq.confidence ? current : best
                );
                
                return {
                    frequency: bestFrequency.freq.frequency,
                    confidence: bestFrequency.freq.confidence,
                    method: bestFrequency.method
                };
            }
            
            // Find strongest frequency in a specific range
            findStrongestInRange(freqData, range, sampleRate, fftSize) {
                const minBin = Math.floor(range.min * fftSize / sampleRate);
                const maxBin = Math.floor(range.max * fftSize / sampleRate);
                
                let maxIndex = 0;
                let maxValue = 0;
                
                // Search only in the specified frequency range
                for (let i = minBin; i <= maxBin && i < freqData.length; i++) {
                    if (freqData[i] > maxValue) {
                        maxValue = freqData[i];
                        maxIndex = i;
                    }
                }
                
                if (maxValue > 5) {
                    const frequency = maxIndex * sampleRate / fftSize;
                    return {
                        frequency: frequency,
                        confidence: maxValue / 255,
                        index: maxIndex
                    };
                }
                
                return { frequency: 0, confidence: 0, index: 0 };
            }
            
            // Check if a frequency might be a harmonic of a lower fundamental
            checkForHarmonic(freqData, detectedFreq, sampleRate, fftSize) {
                // Common harmonic ratios: 2x, 3x, 4x, 5x, 6x, 8x
                const harmonicRatios = [2, 3, 4, 5, 6, 8];
                
                for (const ratio of harmonicRatios) {
                    const fundamentalFreq = detectedFreq / ratio;
                    
                    // Check if fundamental frequency exists and is strong
                    if (fundamentalFreq >= 20 && fundamentalFreq <= 200) { // Bass range
                        const fundamentalBin = Math.floor(fundamentalFreq * fftSize / sampleRate);
                        
                        if (fundamentalBin < freqData.length && fundamentalBin > 0) {
                            const fundamentalStrength = freqData[fundamentalBin];
                            
                            // If fundamental is strong enough, it's likely the true frequency
                            if (fundamentalStrength > 10) {
                                return {
                                    isHarmonic: true,
                                    fundamental: fundamentalFreq,
                                    harmonic: detectedFreq,
                                    ratio: ratio,
                                    fundamentalStrength: fundamentalStrength
                                };
                            }
                        }
                    }
                }
                
                return { isHarmonic: false };
            }
            
            // Zero-crossing detection - simple but effective for guitar strings
            zeroCrossingDetection(timeData) {
                const sampleRate = this.audioContext.sampleRate;
                const minFreq = 50;
                const maxFreq = 600;
                
                let crossings = 0;
                let lastSign = timeData[0] >= 0;
                
                // Count zero crossings
                for (let i = 1; i < timeData.length; i++) {
                    const currentSign = timeData[i] >= 0;
                    if (currentSign !== lastSign) {
                        crossings++;
                        lastSign = currentSign;
                    }
                }
                
                // Calculate frequency from zero crossings
                const duration = timeData.length / sampleRate;
                const frequency = crossings / (2 * duration);
                
                // Check if frequency is in guitar range
                if (frequency >= minFreq && frequency <= maxFreq) {
                    // Calculate confidence based on signal strength
                    const signalStrength = this.calculateSignalStrengthFromTime(timeData);
                    const confidence = Math.min(1.0, signalStrength / 0.1);
                    
                    return {
                        frequency: frequency,
                        confidence: confidence,
                        crossings: crossings
                    };
                }
                
                return { frequency: 0, confidence: 0, crossings: 0 };
            }
            
            calculateSignalStrengthFromTime(timeData) {
                let sum = 0;
                for (let i = 0; i < timeData.length; i++) {
                    sum += Math.abs(timeData[i]);
                }
                return sum / timeData.length;
            }
            
            calculateCents(frequency, noteFrequency) {
                return Math.round(1200 * Math.log2(frequency / noteFrequency));
            }
            
            updateNeedle(cents) {
                this.tunerNeedle.className = 'tuner-needle';
                
                // Update needle
                if (Math.abs(cents) <= 10) {
                    // In tune (within 10 cents)
                    this.tunerNeedle.classList.add('in-tune');
                } else if (cents > 0) {
                    // Sharp
                    this.tunerNeedle.classList.add('sharp');
                } else {
                    // Flat
                    this.tunerNeedle.classList.add('flat');
                }
            }
            
            updateStringVisual(detectedString, cents) {
                if (!detectedString) return;
                
                // Clear all previous visual states
                this.clearAllStringVisuals();
                
                // Highlight the detected string
                const stringElements = document.querySelectorAll(`[data-string="${detectedString.string}"]`);
                stringElements.forEach(el => {
                    el.classList.add('detected');
                });
                
                // Update tuning status on the detected string
                this.updateStringTuningStatus(detectedString.string, cents);
                
                // Update the main display to show which string was detected
                this.noteDisplay.textContent = detectedString.note;
                

            }
            
            updateStringTuningStatus(stringNumber, cents) {
                const stringElements = document.querySelectorAll(`[data-string="${stringNumber}"]`);
                
                // Remove all tuning classes
                stringElements.forEach(el => {
                    el.classList.remove('in-tune', 'sharp', 'flat');
                });
                
                // Add appropriate tuning class
                if (Math.abs(cents) <= 10) {
                    stringElements.forEach(el => el.classList.add('in-tune'));
                } else if (cents > 0) {
                    stringElements.forEach(el => el.classList.add('sharp'));
                } else {
                    stringElements.forEach(el => el.classList.add('flat'));
                }
            }
            
            clearAllStringVisuals() {
                const allElements = document.querySelectorAll('.string-item');
                allElements.forEach(el => {
                    el.classList.remove('detected', 'in-tune', 'sharp', 'flat');
                });
            }
            
            updateConfidence(confidence, frequencyAccuracy = null, result = null) {
                this.confidenceFill.style.width = `${confidence}%`;
                
                // Update confidence text with detailed information
                let confidenceText = `${confidence}%`;
                
                if (result && result.string) {
                    // Guitar string detected - show cents deviation
                    if (result.cents !== undefined) {
                        const centsAbs = Math.abs(result.cents);
                        if (centsAbs <= 5) {
                            confidenceText += ` (Perfect Tuning)`;
                        } else if (centsAbs <= 10) {
                            confidenceText += ` (Good Tuning)`;
                        } else if (centsAbs <= 20) {
                            confidenceText += ` (Acceptable)`;
                        } else {
                            confidenceText += ` (Needs Tuning)`;
                        }
                    }
                } else if (frequencyAccuracy !== null) {
                    // General frequency detection - show Hz accuracy
                    confidenceText += ` (Â±${frequencyAccuracy.toFixed(1)} Hz)`;
                }
                
                this.confidenceText.textContent = confidenceText;
                
                // Update confidence bar color based on level
                if (confidence < 30) {
                    this.confidenceFill.style.background = 'var(--danger-color)';
                } else if (confidence < 70) {
                    this.confidenceFill.style.background = 'var(--warning-color)';
                } else {
                    this.confidenceFill.style.background = 'var(--success-color)';
                }
            }
            
            resetStringVisual() {
                this.clearAllStringVisuals();
                this.tunerNeedle.className = 'tuner-needle';
                this.updateConfidence(0);
            }
            
            showStatus(message, type) {
                // Remove existing status
                const existingStatus = document.querySelector('.status-indicator');
                if (existingStatus) {
                    existingStatus.remove();
                }
                
                // Create new status
                const status = document.createElement('div');
                status.className = `status-indicator ${type}`;
                status.textContent = message;
                
                // Insert after tuner display
                const tunerDisplay = document.querySelector('.tuner-display');
                tunerDisplay.parentNode.insertBefore(status, tunerDisplay.nextSibling);
                
                // Remove after 5 seconds
                setTimeout(() => {
                    if (status.parentNode) {
                        status.remove();
                    }
                }, 5000);
            }
        }
        
        // Initialize the tuner when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing GuitarTuner...');
            try {
                const tuner = new GuitarTuner();
                console.log('GuitarTuner initialized successfully:', tuner);
            } catch (error) {
                console.error('Error initializing GuitarTuner:', error);
            }
        });
    </script>
</body>
</html>
